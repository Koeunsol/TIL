
# Seaborn 라이브러리를 활용한 지난 시간 복습


```python
import seaborn
```


```python
from numpy.random import binomial
```

#### 이항 분포


```python
x = binomial(10, .4, 100) # 앞면이 나올 확률 .4인 동전 10개를 던졌을 때 실제로 앞면은 몇 개씩 나올까?
```


```python
seaborn.distplot(x, bins=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
# x축은 총 100번 중 각 구간의 숫자만큼 앞면이 나온 총합, y축은 확률
# bins = []로 구간 직접 설정 가능, bins는 히스토그램의 막대 갯수를 설정하는 것.
# 'bins = 5' 라고 입력하면 구간을 임의로 나눈 막대 5개가 그려지고,
# 'bins = [1, 2, 3, 4, 5]'라고 입력하면 5 이후의 값은 5의 그래프에 합쳐져서 같이 나온다.
```




    <matplotlib.axes._subplots.AxesSubplot at 0x1b0b4e37dd8>




![png](output_5_1.png)



```python
seaborn.distplot(x, bins=5)
```




    <matplotlib.axes._subplots.AxesSubplot at 0x1b0b241fe80>




![png](output_6_1.png)



```python
seaborn.distplot(x, bins=[1, 2, 3, 4, 5])
```




    <matplotlib.axes._subplots.AxesSubplot at 0x1b0b2568518>




![png](output_7_1.png)


## 실습
아래 각 분포로 데이터를 만들어서 seaborn.distplot으로 그래프 그려보기.

### 이산
- 기하 분포
- 음이항 분포
- 포아송 분포

### 연속
- 균등 분포
- 정규 분포
- 지수 분포


```python
from numpy.random import geometric, negative_binomial, exponential, multinomial, poisson, uniform, normal
```

#### 기하 분포


```python
g = geometric(.3, 100) # 성공률 30%, 성공할 때까지 걸린 횟수를 100회 구해보기
```


```python
seaborn.distplot(g)
```




    <matplotlib.axes._subplots.AxesSubplot at 0x1b0b3583240>




![png](output_12_1.png)


#### 음이항 분포


```python
nb = negative_binomial(10, .1,
                       100) # 성공률 1%, 10번 달성할 때까지 걸리는 시간을 총 100회 구해보기
```


```python
nb
```




    array([109,  93, 101,  84,  67,  59,  85, 133, 104,  67,  96, 149, 125,
            80,  92, 123, 104, 109,  66,  91, 105,  77,  86,  93,  54,  63,
           122,  82, 125,  77,  78,  87, 112, 107,  50,  60, 108,  45,  58,
           115,  91,  71,  96,  89, 116,  38,  58,  70, 127,  62,  53,  72,
            57,  80,  55,  82, 171,  98,  72,  61,  84, 156, 101,  77,  77,
           153,  58, 102,  99,  99,  60,  99, 131, 107, 124,  65,  88,  76,
            77,  87, 163,  84, 128,  66,  55,  66,  72,  81, 109,  44, 106,
            60, 173,  63, 118,  95,  80, 104, 114,  68])




```python
seaborn.distplot(nb)
```




    <matplotlib.axes._subplots.AxesSubplot at 0x1b0b4c909b0>




![png](output_16_1.png)


#### 포아송 분포


```python
p = poisson(20, 100) # 평균 20회일 때 100일 동안 실행되는 횟수
```


```python
seaborn.distplot(p)
```




    <matplotlib.axes._subplots.AxesSubplot at 0x1b0b4abf4e0>




![png](output_19_1.png)


#### 균등 분포


```python
u = uniform(1, 10, 50) # 1~10까지 숫자를 균등한 확률로 하나씩 뽑는 것을 총 50회 반복
```


```python
seaborn.distplot(u)
```




    <matplotlib.axes._subplots.AxesSubplot at 0x1b0b352af98>




![png](output_22_1.png)


#### 정규 분포


```python
n = normal(30, 10, 100) #고객이 평균 30만원(표준편차 10만원)을 쓸 때 각 고객이 쓰는 돈을 총 100회 구해보기
```


```python
seaborn.distplot(n)
```




    <matplotlib.axes._subplots.AxesSubplot at 0x1b0b4c904e0>




![png](output_25_1.png)


#### 지수 분포


```python
e = exponential(10, 100) # 평균 10씩 걸리는 사건이 다음 사건이 일어날 때까지 걸리는 시간을 총 100회 반복
```


```python
seaborn.distplot(e)
```




    <matplotlib.axes._subplots.AxesSubplot at 0x1b0b4b9a6a0>




![png](output_28_1.png)


#### 과제 : 리트리버 분포
우리 리트리버는 10%의 확률로 짜증이 납니다. 이틀 연속으로 짜증이 나면 화를 냅니다. 리트리버가 화를 낼 때까지 기간을 시뮬레이션 해보세요.


```python
한계 = 2
옐로카드 = 0
짜증확률 = .1
기간 = 0

while 옐로카드 < 한계:
    짜증 = binomial(1, 짜증확률)
    if 짜증 == 1:
        옐로카드 += 1
    else:
        옐로카드 = 0
    기간 += 1
기간
```




    35




```python
개판 = []
for i in range(100):
    한계 = 2
    옐로카드 = 0
    짜증확률 = .1
    기간 = 0
    
    while 옐로카드 < 한계:
        짜증 = binomial(1, 짜증확률)
        if 짜증 == 1:
            옐로카드 += 1
        else:
            옐로카드 = 0
        기간 += 1
    개판.append(기간)
seaborn.distplot(개판)
```




    <matplotlib.axes._subplots.AxesSubplot at 0x1b0b4edefd0>




![png](output_31_1.png)


## 확률 분포
- 데이터를 만드는(만들어진) 방법

## 모수 (= Parameter)
- 일종의 설정값
- 데이터의 분포(데이터의 모양, 분포의 성격)를 결정하는 수치
- 각 분포를 구할 때 총 반복 횟수에 해당하는 숫자는 모수가 아니다. 확률에 영향을 주는 숫자가 아님.

## 데이터
- 분포에서 나온 것

# 집합
- 전체 집합
- 부분 집합
- 합집합
- 교집합

# 확률
- 확률 P(A) : 전체에서 A가 얼마나 되는가
- 결합 확률 P(A, B) : 전체 중 A와 B 모두를 충족하는 경우
- 조건부 확률 P(B|A) = P(A, B) / P(A) : A를 만족하는 사람들 중에서 B도 만족하는 경우. ex) 검은 옷 입은 사람 중에서 안경을 쓰고 있는 비율.
    - Q. 세관 직원의 실력은 무엇으로 판단할까?  
    - (1) P(잡았, 노양심) (2) P(노양심|잡았) (3) P(잡았|노양심)  
    - A. (2), 세관은 잡고 나서의 결과만 알 수 있기 때문에 (3)은 계산 자체가 불가능.

- 두 사건 A, B가 독립이면 P(A|B) = P(A) 이고 P(B|A) =P(B)

## 그래프 모형
- 각 집합이 다른 집합에 미치는 영향을 화살표 그림으로 나타낼 수 있다.
- 순환 고리가 생기면 안 된다.
- 서로 영향을 주고 받는 경우는 사실 따져보면 시점이 다르거나 변수가 여러 개일 수 있으므로 분리해서 한 방향으로만 가게 설정하기.
- 모델이 복잡할 수록 맞을 확률이 줄어드니 모델은 가급적 간단하게 만들기.
- 단일 사례는 각 요인들이 결과에 미치는 인과관계를 특정하기 어렵기 때문에 모형을 만들기에 적합하지 못 하다.

## Explaining Away
- 독립관계인 A, B가 모두 C에 영향을 줄 때, 간접적으로 A와 B 사이에 관계가 생긴다.

## 측정
- 불가능한 것 : 사랑, 지능 등 심리학에서 주로 다루는 지표
- 현실적으로 어려운 것 : 외모 등 물리적으로 크기가 없는 것

### 실습 코드


```python
# 연기력 : 연속, 매출 : 연속이므로 둘 다 정규 분포를 따른다고 가정.
연기력 = normal(50, 15, 100) # 평균 50, 표준편차 15인 배우 100명
```


```python
연기력
```




    array([16.34255177, 42.88944054, 42.33242012, 37.32626136, 40.62804709,
           31.48489724, 54.72947428, 47.70074531, 46.02372769, 39.84423039,
           69.42145487, 41.38428192, 66.21906076, 42.11534742, 45.90741048,
           53.30732493, 74.51108831, 69.11768553, 67.81664422, 21.6528413 ,
           52.18860521, 33.96683915, 78.26800803, 34.3945297 , 49.46997599,
           54.58330004, 78.54250419, 28.57404745, 44.80838972, 62.1759625 ,
           29.38939294, 62.73452692, 43.9034862 , 71.99380319, 37.24765886,
           50.52363976, 64.33224212, 31.64785343, 36.87379268, 62.92489383,
           91.85826769, 38.29508692, 40.33844052, 65.72405678, 62.53797886,
           39.36442478, 32.50951219, 70.49956874, 40.82310766, 17.61555456,
           47.1421597 , 28.51148   , 40.24639048, 58.08678016, 49.39453305,
           45.23798765, 63.25956322, 17.73293412, 52.05719451, 48.64737243,
           56.66161209, 41.02226225, 46.67827935, 43.41479248, 59.4167341 ,
           28.81800903, 39.81167399, 33.03158901, 60.20061093, 52.78167481,
           55.94727725, 32.48844302, 40.3379479 , 42.90737081, 57.70849952,
           48.53926978, 49.48006987, 34.44108424, 46.86768262, 53.49783123,
           44.97307375, 42.46876201, 68.09306799, 55.83925605, 60.47033493,
           55.15048499, 67.92037973, 66.64856476, 82.63990085, 44.87382596,
           45.59897908, 36.90111794, 39.750788  , 73.4516923 , 47.42702701,
           31.2032244 , 67.69136053, 69.57791139, 27.71406908, 70.11423794])




```python
seaborn.distplot(연기력)
```




    <matplotlib.axes._subplots.AxesSubplot at 0x1b0b4fd2240>




![png](output_42_1.png)



```python
평균매출 = 10 * 연기력 + 20000
```


```python
평균매출 # 연기력과 매출을 이어주는 화살표 역할, 연기력이 평균에 영향을 주기 때문에 그 평균이 매출의 데이터 모양을 바꾸는 것.
```




    array([20163.42551767, 20428.8944054 , 20423.32420125, 20373.26261355,
           20406.28047087, 20314.84897244, 20547.29474282, 20477.00745308,
           20460.23727689, 20398.44230392, 20694.2145487 , 20413.84281922,
           20662.19060758, 20421.15347416, 20459.07410481, 20533.07324926,
           20745.11088307, 20691.17685531, 20678.1664422 , 20216.52841301,
           20521.88605214, 20339.66839148, 20782.68008032, 20343.94529695,
           20494.69975995, 20545.83300039, 20785.42504193, 20285.74047446,
           20448.08389721, 20621.75962503, 20293.89392936, 20627.34526918,
           20439.03486198, 20719.93803187, 20372.4765886 , 20505.23639763,
           20643.32242119, 20316.47853426, 20368.73792678, 20629.24893834,
           20918.58267691, 20382.95086918, 20403.38440524, 20657.24056776,
           20625.37978859, 20393.64424781, 20325.09512189, 20704.99568745,
           20408.23107657, 20176.15554558, 20471.42159695, 20285.11480003,
           20402.46390484, 20580.86780164, 20493.94533049, 20452.3798765 ,
           20632.59563223, 20177.32934118, 20520.57194505, 20486.47372428,
           20566.61612092, 20410.22262248, 20466.78279347, 20434.14792476,
           20594.16734098, 20288.18009032, 20398.11673988, 20330.31589015,
           20602.00610932, 20527.8167481 , 20559.47277249, 20324.88443024,
           20403.37947897, 20429.07370805, 20577.08499522, 20485.3926978 ,
           20494.80069867, 20344.41084244, 20468.67682622, 20534.97831228,
           20449.73073748, 20424.68762015, 20680.9306799 , 20558.39256054,
           20604.70334935, 20551.50484994, 20679.20379731, 20666.48564755,
           20826.3990085 , 20448.7382596 , 20455.98979076, 20369.01117944,
           20397.50788004, 20734.516923  , 20474.27027009, 20312.03224403,
           20676.91360526, 20695.77911387, 20277.14069084, 20701.14237935])




```python
매출 = normal(평균매출, 1000) # 이미 평균매출에 100개의 값이 들어가있어서 따로 설정해주지 않아도 100개의 결과가 나온다
```


```python
매출
```




    array([20065.93130706, 19869.27839188, 19762.71179502, 20496.96401089,
           21006.4062594 , 19974.35617379, 19914.3563203 , 20355.90721501,
           20515.29130315, 21401.69726194, 20999.52851236, 18519.57283069,
           17477.43703942, 20705.45311408, 20221.1372987 , 20528.60072698,
           20952.17739962, 21251.84593279, 21014.35019105, 19773.93318276,
           19724.91379302, 20400.30584375, 19946.96385094, 21882.64400723,
           21344.988742  , 19812.38624748, 20965.14043988, 22642.1641194 ,
           21536.94603897, 20490.31926538, 20450.76573814, 21064.35753324,
           20899.5875019 , 22530.10538999, 20331.70423773, 20225.89962604,
           23155.23887446, 21570.3868951 , 19288.89247085, 22424.34176433,
           21386.00707016, 21004.855215  , 19356.84454339, 20840.44173386,
           21179.37006286, 21105.4010687 , 20094.23021823, 20690.95844124,
           19827.9513283 , 19602.71707969, 18804.12891886, 20382.43500885,
           22584.72638736, 18213.2336819 , 20410.19265502, 21483.1330922 ,
           19289.43879108, 20182.55952771, 19326.62239173, 21929.66788148,
           19468.42628157, 18269.81719772, 20611.73687319, 21263.48063181,
           20400.54805391, 20594.66324098, 21438.08137851, 20488.6054233 ,
           20696.28139375, 20285.16899834, 21931.75520369, 19403.88647052,
           21921.09771173, 21373.8879927 , 20937.55391047, 21136.62892878,
           20331.46212775, 22648.40077226, 21005.83858135, 19097.2181487 ,
           21323.14376556, 18971.89580811, 22154.69440136, 19712.79118219,
           20864.06299894, 22280.54345932, 20189.52650822, 21183.73845078,
           20663.35738827, 20509.63118664, 19839.37359195, 21839.43152013,
           17708.89780787, 22130.4619968 , 22106.91600527, 19730.53012841,
           20432.71335531, 22624.47811793, 19384.72872874, 22111.36218052])




```python
seaborn.distplot(매출)
```




    <matplotlib.axes._subplots.AxesSubplot at 0x1b0b6720ac8>




![png](output_47_1.png)



```python
seaborn.jointplot(연기력, 매출) # 각각의 점은 개별 작품, x축은 연기력, y축은 매출
```




    <seaborn.axisgrid.JointGrid at 0x1b0b67f6470>




![png](output_48_1.png)


### 연기의 영향이 매출의 표준편차에 영향을 미치는 모형


```python
연기의영향 = 1000 * 연기력 # 표준편차로 사용함
```


```python
매출 = normal(20000, 연기의영향)
```


```python
seaborn.jointplot(연기력, 매출)
```




    <seaborn.axisgrid.JointGrid at 0x1b0b68b35f8>




![png](output_52_1.png)


### 연기의 영향이 매출의 평균에 영향을 미치는 모형


```python
연기의영향 = 100 * 연기력 + 20000
매출 = normal(연기의영향, 800)
```


```python
seaborn.jointplot(연기력, 매출)
```




    <seaborn.axisgrid.JointGrid at 0x1b0b6cc01d0>




![png](output_55_1.png)


## 로지스틱 선형 모형


```python
from scipy.special import expit # 어떤 값을 넣어도 0~1 사이의 값을 출력
```


```python
expit(10)
```




    0.9999546021312976




```python
expit(-5)
```




    0.0066928509242848554




```python
expit(0)
```




    0.5



### 연기력 예시


```python
# expit를 쓰지 않으면 음의 값을 가지는 값이 있어 연산이 안 되는 경우가 있으므로 expit을 사용해 무조건 0~1의 값을 가지도록 함
연기의영향 = expit(0.5 * 연기력 - 25)
```


```python
연기의영향
```




    array([4.91335289e-08, 2.77796232e-02, 2.11696469e-02, 1.76670757e-03,
           9.13942412e-03, 9.53795119e-05, 9.14098508e-01, 2.40557156e-01,
           1.20454188e-01, 6.19446865e-03, 9.99939374e-01, 1.32835139e-02,
           9.99699430e-01, 1.90337135e-02, 1.14427311e-01, 8.39385429e-01,
           9.99995241e-01, 9.99929431e-01, 9.99864760e-01, 6.99024498e-07,
           7.49191064e-01, 3.29837543e-04, 9.99999273e-01, 4.08448924e-04,
           4.34132049e-01, 9.08183132e-01, 9.99999366e-01, 2.22537832e-05,
           6.94088829e-02, 9.97735154e-01, 3.34540739e-05, 9.98286091e-01,
           4.52927877e-02, 9.99983247e-01, 1.69873614e-03, 5.65083606e-01,
           9.99228283e-01, 1.03475388e-04, 1.40950857e-03, 9.98441461e-01,
           9.99999999e-01, 2.86460372e-03, 7.91711537e-03, 9.99615056e-01,
           9.98109439e-01, 4.87966252e-03, 1.59191431e-04, 9.99964636e-01,
           1.00662859e-02, 9.28553609e-08, 1.93266993e-01, 2.15683937e-05,
           7.56368185e-03, 9.82764361e-01, 4.24889399e-01, 8.46325848e-02,
           9.98681290e-01, 9.84681157e-08, 7.36643854e-01, 3.37084523e-01,
           9.65470651e-01, 1.11085567e-02, 1.59646542e-01, 3.58257971e-02,
           9.91061130e-01, 2.51407474e-05, 6.09505973e-03, 2.06664846e-04,
           9.93942038e-01, 8.00725896e-01, 9.51368899e-01, 1.57523481e-04,
           7.91518095e-03, 2.80227805e-02, 9.79250184e-01, 3.25114612e-01,
           4.35372296e-01, 4.18063999e-04, 1.72764691e-01, 8.51815977e-01,
           7.49197378e-02, 2.26293329e-02, 9.99882215e-01, 9.48808235e-01,
           9.94702283e-01, 9.29251132e-01, 9.99871595e-01, 9.99757504e-01,
           9.99999918e-01, 7.15521924e-02, 9.97046588e-02, 1.42887062e-03,
           5.91338451e-03, 9.99991918e-01, 2.16448102e-01, 8.28506762e-05,
           9.99856018e-01, 9.99943936e-01, 1.44765576e-05, 9.99957122e-01])




```python
주연상 = binomial(5, 연기의영향) # 5개의 영화제에서 연기의 영향을 받는 주연상을 받는 횟수
```


```python
주연상
```




    array([0, 0, 0, 0, 0, 0, 4, 2, 0, 0, 5, 0, 5, 0, 1, 5, 5, 5, 5, 0, 3, 0,
           5, 0, 4, 5, 5, 0, 0, 5, 0, 5, 0, 5, 0, 3, 5, 0, 0, 5, 5, 0, 0, 5,
           5, 1, 0, 5, 0, 0, 1, 0, 0, 4, 2, 0, 5, 0, 2, 4, 5, 0, 0, 0, 5, 0,
           0, 0, 5, 4, 5, 0, 0, 0, 5, 0, 3, 0, 2, 4, 0, 0, 5, 4, 5, 5, 5, 5,
           5, 0, 0, 0, 0, 5, 1, 0, 5, 5, 0, 5])




```python
seaborn.jointplot(연기력, 주연상)
```




    <seaborn.axisgrid.JointGrid at 0x1b0b8499ac8>




![png](output_66_1.png)



```python
주연상 = binomial(1, 연기의영향)
```


```python
seaborn.jointplot(연기력, 주연상)
```




    <seaborn.axisgrid.JointGrid at 0x1b0b95a3cc0>




![png](output_68_1.png)


#### CASE 2


```python
실력 = normal(50, 15, 100)
```


```python
실력의영향 = expit(0.5 * 실력 - 25) # 0.5는 변별력을 결정하는 역할을 한다고 볼 수 있음
```


```python
합격 = binomial(1, 실력의영향)
```


```python
seaborn.jointplot(실력, 합격)
```




    <seaborn.axisgrid.JointGrid at 0x1b0b97f9710>




![png](output_73_1.png)


#### CASE 3  
- 선형모형 : 이산형 -> 연속형


```python
공기청정기 = binomial(1, .6, 100)
```


```python
청정기의영향 = 8 * 공기청정기 + 8 # 청정기가 안 돌아가는 경우 9, 작동하는 경우 16
```


```python
공기질 = normal(청정기의영향, 30)
```


```python
공기질
```




    array([-4.59248917e+01,  1.93669567e+01, -9.90758600e-01, -5.34323758e+01,
            5.85433419e+01,  1.79315378e+01, -1.14387796e+01,  2.45987849e+00,
           -1.75427189e+01, -3.93461712e-02, -1.88983155e+01,  1.47979610e+01,
            5.68765256e+01,  3.91190412e+00,  1.24187044e+01, -1.64092864e+01,
            1.21842944e+01,  4.77324357e+01, -2.57874551e+01,  2.64056151e+01,
           -4.15521852e+01,  9.18649539e+00,  3.19007021e+01,  3.47341885e+01,
            6.04450004e+01,  6.12440803e+00,  4.31885572e+00,  5.32644825e+01,
           -9.97307732e+00,  2.29395732e+01, -5.50610242e+01,  2.43647146e+01,
            1.62017664e+01, -5.00528732e+01,  2.49689386e+01, -5.59319258e-01,
            3.85014855e+01, -5.66159169e+00, -2.81886886e+01,  1.49346535e+01,
            7.45574160e+00,  4.95258961e+01,  2.41075131e+01,  4.54196563e+01,
            1.92162224e+01, -7.66821090e+00,  2.85990170e+00,  2.50316978e+00,
           -1.09562323e+01,  3.14943273e+01,  8.96238080e+00,  1.94101791e+01,
            2.42385974e+00,  6.26834848e+01, -3.98162142e+01,  2.98892416e+01,
            4.73089956e+01, -7.91975779e-01, -8.13231882e-01,  2.45598959e+00,
            3.66393346e+01,  1.26827807e+01,  3.92031645e+01,  5.97043582e+01,
            1.86499108e+01, -1.26814398e+01,  5.05474718e+01,  6.39490839e+00,
            3.61416117e+01,  1.06036102e+01, -2.12042600e+00,  2.07481670e+01,
            2.68363008e+01,  3.48829498e+01,  3.55167470e+01, -1.78237012e+01,
            2.81058450e+01,  1.46058104e+01, -3.19662016e+01, -2.22564088e+00,
            3.79456661e+01,  3.50897036e+01,  3.20804765e+01,  3.58702725e+00,
            2.74673831e+01,  2.37771015e+01,  2.82454111e+01, -3.57138523e+01,
           -3.73426949e+00,  3.07772676e+01,  1.28774215e+01,  3.89146755e+01,
            1.23856567e+01, -1.59528965e+01,  3.10462964e+01,  5.59014846e+01,
            4.18511458e+00, -1.04189121e+01, -3.77429835e-01,  1.99200465e+01])



- 로지스틱 선형 모형 : 이산형 -> 이산형


```python
공기청정기 = binomial(1, .6, 100)
청정기의영향 = expit(2 * 공기청정기 - 1)
앨러지 = binomial(1, 청정기의영향)
```

아래의 if문과 같은 의미를 가지고 있다.


```python
if 공기청정기 == 1:
    청정기의영향 = 0.73
else:
    청정기의영향 = 0.26
```


    ---------------------------------------------------------------------------

    ValueError                                Traceback (most recent call last)

    <ipython-input-232-cb91c14058b0> in <module>
    ----> 1 if 공기청정기 == 1:
          2     청정기의영향 = 0.73
          3 else:
          4     청정기의영향 = 0.26
    

    ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()



```python

```
